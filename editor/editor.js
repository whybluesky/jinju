class ImageEditor {
  constructor() {
    this.canvas = document.getElementById('previewCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.selectedText = '';
    this.settings = {
      fontSize: 24,
      lineHeight: 1.5,
      padding: 40,
      borderRadius: 0,
      fontFamily: 'Arial',
      textAlign: 'left',
      textColor: '#000000',
      backgroundColor: '#ffffff',
      decorations: {
        activeDecorations: new Set(),
        options: {
          'quote-marks': {
            color: '#EEEEEE',
            size: 72,
            position: 'top-left'
          },
          'border': {
            style: 'solid',
            width: 2,
            color: '#EEEEEE',
            radius: 0
          },
          'watermark': {
            text: 'Generated by Text2Image',
            opacity: 0.1,
            angle: -45
          },
          'texture': {
            pattern: 'lines',
            opacity: 0.1,
            scale: 1
          },
          'corner': {
            style: 'simple',
            color: '#EEEEEE',
            size: 40
          },
          'pattern': {
            type: 'dots',
            color: '#EEEEEE',
            opacity: 0.1,
            scale: 1
          }
        }
      },
      currentTemplate: 'simple',
      backgroundImage: null,
      backgroundSize: 'cover',  // 'cover' | 'contain' | 'repeat'
      backgroundOpacity: 1,
      filters: {
        brightness: 100,
        contrast: 100,
        saturation: 100,
        blur: 0
      }
    };
    
    this.customFonts = new Map();  // å­˜å‚¨è‡ªå®šä¹‰å­—ä½“
    this.history = [];
    this.loadHistory();
    this.loadCustomFonts();
    this.loadFonts();
    this.initializeCanvas();
    this.bindEvents();
    this.exportSettings = {
      format: 'png',
      quality: 0.9,
      width: 800,
      height: 600,
      maintainRatio: true
    };
  }

  async loadCustomFonts() {
    try {
      const result = await chrome.storage.local.get('customFonts');
      const storedFonts = result.customFonts || [];
      
      for (const fontData of storedFonts) {
        await this.loadFontFromData(fontData);
      }
    } catch (err) {
      console.error('åŠ è½½è‡ªå®šä¹‰å­—ä½“å¤±è´¥:', err);
    }
  }

  async loadFontFromData(fontData) {
    try {
      const fontFace = new FontFace(fontData.name, `url(data:font/ttf;base64,${fontData.data})`);
      const loadedFont = await fontFace.load();
      document.fonts.add(loadedFont);
      this.customFonts.set(fontData.name, fontData);
      
      // æ›´æ–°å­—ä½“é€‰æ‹©å™¨
      this.updateFontSelect();
    } catch (err) {
      console.error('åŠ è½½å­—ä½“å¤±è´¥:', err);
    }
  }

  updateFontSelect() {
    const fontSelect = document.getElementById('fontSelect');
    const customFontOptions = Array.from(this.customFonts.keys()).map(fontName => 
      `<option value="${fontName}">${fontName}</option>`
    ).join('');
    
    // ä¿æŒå½“å‰é€‰ä¸­çš„å­—ä½“
    const currentFont = fontSelect.value;
    fontSelect.innerHTML = `
      <option value="Arial">Arial</option>
      <option value="Georgia">Georgia</option>
      <option value="Microsoft YaHei">å¾®è½¯é›…é»‘</option>
      <option value="FZKTJW">æ–¹æ­£æ¥·ä½“</option>
      ${customFontOptions}
    `;
    fontSelect.value = currentFont;
  }

  async loadFonts() {
    // åŠ è½½è‡ªå®šä¹‰å­—ä½“
    const fontFaces = [
      new FontFace('FZKTJW', 'url(../assets/fonts/FZKTJW.ttf)'),
      // å¯ä»¥æ·»åŠ æ›´å¤šå­—ä½“
    ];
    
    try {
      const loadedFonts = await Promise.all(fontFaces.map(font => font.load()));
      loadedFonts.forEach(font => document.fonts.add(font));
    } catch (err) {
      console.error('å­—ä½“åŠ è½½å¤±è´¥:', err);
    }
  }

  applyTemplate(templateName) {
    const template = TEMPLATES[templateName];
    if (!template) return;
    
    this.settings = {
      ...this.settings,
      ...template.styles,
      currentTemplate: templateName
    };
    
    // æ›´æ–°UIæ§ä»¶çš„å€¼
    document.getElementById('fontSize').value = this.settings.fontSize;
    document.getElementById('lineHeight').value = this.settings.lineHeight;
    document.getElementById('padding').value = this.settings.padding;
    document.getElementById('borderRadius').value = this.settings.borderRadius;
    
    this.render();
  }

  initializeCanvas() {
    this.canvas.width = 800;
    this.canvas.height = 600;
    this.ctx.fillStyle = this.settings.backgroundColor;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }

  bindEvents() {
    // ç›‘å¬æ¥è‡ªcontent scriptçš„æ¶ˆæ¯
    window.addEventListener('message', (event) => {
      if (event.data.type === 'selectedText') {
        this.selectedText = event.data.text;
        this.render();
      }
    });

    // ç»‘å®šè®¾ç½®å˜æ›´äº‹ä»¶
    document.getElementById('fontSize').addEventListener('input', (e) => {
      this.settings.fontSize = parseInt(e.target.value);
      this.render();
    });

    document.getElementById('lineHeight').addEventListener('input', (e) => {
      this.settings.lineHeight = parseFloat(e.target.value);
      this.render();
    });

    document.getElementById('padding').addEventListener('input', (e) => {
      this.settings.padding = parseInt(e.target.value);
      this.render();
    });

    document.getElementById('borderRadius').addEventListener('input', (e) => {
      this.settings.borderRadius = parseInt(e.target.value);
      this.render();
    });

    // å¯¹é½æ–¹å¼æŒ‰é’®
    document.querySelectorAll('.align-buttons button').forEach(button => {
      button.addEventListener('click', () => {
        this.settings.textAlign = button.dataset.align;
        this.render();
      });
    });

    // ä¿å­˜æŒ‰é’®
    document.getElementById('saveBtn').addEventListener('click', () => {
      this.saveImage();
    });

    // å…³é—­æŒ‰é’®
    document.getElementById('closeBtn').addEventListener('click', () => {
      window.parent.postMessage({ type: 'closeEditor' }, '*');
    });

    // æ¨¡æ¿é€‰æ‹©äº‹ä»¶
    document.getElementById('templateSelect').addEventListener('change', (e) => {
      this.applyTemplate(e.target.value);
    });

    // é¢œè‰²é€‰æ‹©å™¨äº‹ä»¶
    document.getElementById('textColor').addEventListener('input', (e) => {
      this.settings.textColor = e.target.value;
      this.render();
    });

    document.getElementById('bgColor').addEventListener('input', (e) => {
      this.settings.backgroundColor = e.target.value;
      this.render();
    });

    // èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ 
    document.getElementById('bgImageBtn').addEventListener('click', () => {
      document.getElementById('bgImageInput').click();
    });

    document.getElementById('bgImageInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        this.loadBackgroundImage(file);
      }
    });

    // æ ‡ç­¾åˆ‡æ¢
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.panel-content').forEach(p => p.classList.remove('active'));
        btn.classList.add('active');
        document.querySelector(`.${btn.dataset.panel}-content`).classList.add('active');
      });
    });

    // å†å²è®°å½•ç‚¹å‡»äº‹ä»¶
    document.querySelector('.history-list').addEventListener('click', (e) => {
      const historyItem = e.target.closest('.history-item');
      if (historyItem) {
        const id = parseInt(historyItem.dataset.id);
        const item = this.history.find(h => h.id === id);
        if (item) {
          this.settings = { ...item.settings };
          this.selectedText = item.text;
          this.render();
        }
      }
    });

    // åˆ†äº«æŒ‰é’®
    document.getElementById('shareBtn').addEventListener('click', () => {
      this.showSharePanel();
    });

    // å…³é—­åˆ†äº«é¢æ¿
    document.querySelector('.close-share-btn').addEventListener('click', () => {
      document.querySelector('.share-panel').style.display = 'none';
    });

    // åˆ†äº«å¹³å°æŒ‰é’®
    document.querySelectorAll('.share-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        this.shareToPlaftorm(btn.dataset.platform);
      });
    });

    // å­—ä½“é€‰æ‹©äº‹ä»¶
    document.getElementById('fontSelect').addEventListener('change', (e) => {
      this.settings.fontFamily = e.target.value;
      this.render();
    });

    // å­—ä½“ä¸Šä¼ äº‹ä»¶
    document.getElementById('uploadFontBtn').addEventListener('click', () => {
      document.getElementById('fontFileInput').click();
    });

    document.getElementById('fontFileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        await this.handleFontUpload(file);
      }
    });

    // æ»¤é•œæ§åˆ¶äº‹ä»¶
    ['brightness', 'contrast', 'saturation', 'blur'].forEach(filter => {
      document.getElementById(filter).addEventListener('input', (e) => {
        this.settings.filters[filter] = parseFloat(e.target.value);
        this.render();
      });
    });

    // æ»¤é•œé¢„è®¾æŒ‰é’®
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        this.applyFilterPreset(btn.dataset.preset);
      });
    });

    // è£…é¥°å…ƒç´ ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.decoration-item').forEach(item => {
      item.addEventListener('click', () => {
        const type = item.dataset.type;
        this.toggleDecoration(type);
      });
    });

    // å¯¼å‡ºæŒ‰é’®
    document.getElementById('exportBtn').addEventListener('click', () => {
      this.showExportPanel();
    });

    // å…³é—­å¯¼å‡ºé¢æ¿
    document.querySelector('.close-panel-btn').addEventListener('click', () => {
      document.querySelector('.export-panel').style.display = 'none';
    });

    // å¯¼å‡ºè®¾ç½®å˜æ›´äº‹ä»¶
    document.getElementById('formatSelect').addEventListener('change', (e) => {
      this.exportSettings.format = e.target.value;
      this.updateEstimatedSize();
    });

    document.getElementById('qualityRange').addEventListener('input', (e) => {
      this.exportSettings.quality = parseInt(e.target.value) / 100;
      document.querySelector('.quality-value').textContent = `${e.target.value}%`;
      this.updateEstimatedSize();
    });

    // å°ºå¯¸è¾“å…¥äº‹ä»¶
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');

    widthInput.addEventListener('input', () => {
      const width = parseInt(widthInput.value);
      if (this.exportSettings.maintainRatio) {
        const ratio = this.canvas.height / this.canvas.width;
        heightInput.value = Math.round(width * ratio);
      }
      this.updateEstimatedSize();
    });

    heightInput.addEventListener('input', () => {
      const height = parseInt(heightInput.value);
      if (this.exportSettings.maintainRatio) {
        const ratio = this.canvas.width / this.canvas.height;
        widthInput.value = Math.round(height * ratio);
      }
      this.updateEstimatedSize();
    });

    // é”å®šæ¯”ä¾‹æŒ‰é’®
    document.getElementById('lockRatio').addEventListener('click', (e) => {
      this.exportSettings.maintainRatio = !this.exportSettings.maintainRatio;
      e.target.dataset.locked = this.exportSettings.maintainRatio;
      e.target.textContent = this.exportSettings.maintainRatio ? 'ğŸ”’' : 'ğŸ”“';
    });

    // ä¸‹è½½æŒ‰é’®
    document.getElementById('downloadBtn').addEventListener('click', () => {
      this.exportImage();
    });

    // å¤åˆ¶æŒ‰é’®
    document.getElementById('copyBtn').addEventListener('click', () => {
      this.copyToClipboard();
    });
  }

  async loadBackgroundImage(file) {
    try {
      const imageUrl = URL.createObjectURL(file);
      const image = new Image();
      
      image.onload = () => {
        this.settings.backgroundImage = image;
        URL.revokeObjectURL(imageUrl);
        this.render();
      };
      
      image.src = imageUrl;
    } catch (err) {
      console.error('èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥:', err);
    }
  }

  render() {
    // æ¸…ç©ºç”»å¸ƒ
    this.ctx.fillStyle = this.settings.backgroundColor;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // ç»˜åˆ¶èƒŒæ™¯å›¾ç‰‡
    if (this.settings.backgroundImage) {
      this.renderBackgroundImage();
    }

    // ç»˜åˆ¶èƒŒæ™¯è£…é¥°
    if (this.settings.decorations) {
      this.renderDecorations();
    }

    // è®¾ç½®æ–‡å­—æ ·å¼
    this.ctx.font = `${this.settings.fontSize}px ${this.settings.fontFamily}`;
    this.ctx.fillStyle = this.settings.textColor;
    this.ctx.textAlign = this.settings.textAlign;

    // æ–‡å­—æ¢è¡Œå¤„ç†
    const maxWidth = this.canvas.width - (this.settings.padding * 2);
    const text = this.selectedText;
    let lines = [];
    
    // è®¡ç®—æ¯è¡Œèƒ½å®¹çº³çš„å­—ç¬¦æ•°
    let start = 0;
    while (start < text.length) {
      let end = start;
      let lastBreak = start;
      
      while (end < text.length) {
        const testLine = text.slice(start, end + 1);
        const metrics = this.ctx.measureText(testLine);
        
        if (metrics.width > maxWidth) {
          break;
        }
        
        if (text[end] === '\n') {
          lastBreak = end;
          break;
        } else if (text[end] === ' ' || text[end] === 'ï¼Œ' || 
                  text[end] === 'ã€‚' || text[end] === 'ï¼›' ||
                  text[end] === 'ï¼' || text[end] === 'ï¼Ÿ') {
          lastBreak = end;
        }
        end++;
      }
      
      if (lastBreak === start && end < text.length) {
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„æ–­ç‚¹ï¼Œå¼ºåˆ¶æ–­è¡Œ
        lastBreak = end - 1;
      }
      
      lines.push(text.slice(start, lastBreak + 1));
      start = lastBreak + 1;
    }
    
    // è®¡ç®—æ–‡æœ¬æ€»é«˜åº¦
    const lineHeight = this.settings.fontSize * this.settings.lineHeight;
    const totalHeight = lines.length * lineHeight;
    
    // è®¡ç®—èµ·å§‹Yåæ ‡ä»¥å®ç°å‚ç›´å±…ä¸­
    let y = (this.canvas.height - totalHeight) / 2;

    // ç»˜åˆ¶æ–‡å­—
    lines.forEach((line) => {
      let x;
      switch(this.settings.textAlign) {
        case 'center':
          x = this.canvas.width / 2;
          break;
        case 'right':
          x = this.canvas.width - this.settings.padding;
          break;
        default:
          x = this.settings.padding;
      }
      
      this.ctx.fillText(line.trim(), x, y);
      y += lineHeight;
    });

    // åº”ç”¨æ»¤é•œæ•ˆæœ
    this.applyFilters();
  }

  renderDecorations() {
    const { decorations } = this.settings;
    const { activeDecorations, options } = decorations;
    
    if (activeDecorations.has('quote-marks')) {
      const opts = options['quote-marks'];
      this.ctx.font = `${opts.size}px Georgia`;
      this.ctx.fillStyle = opts.color;
      this.ctx.fillText('"', 30, 80);
    }
    
    if (activeDecorations.has('border')) {
      const opts = options.border;
      this.ctx.strokeStyle = opts.color;
      this.ctx.lineWidth = opts.width;
      this.ctx.strokeRect(20, 20, 
        this.canvas.width - 40, 
        this.canvas.height - 40);
    }
    
    if (activeDecorations.has('watermark')) {
      this.ctx.font = '14px Arial';
      this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
      this.ctx.save();
      this.ctx.rotate(-Math.PI / 4);
      this.ctx.fillText('Generated by Text2Image', -50, 400);
      this.ctx.restore();
    }
    
    if (activeDecorations.has('texture')) {
      const pattern = this.ctx.createPattern(this.getTextureImage(), 'repeat');
      this.ctx.fillStyle = pattern;
      this.ctx.globalAlpha = 0.1;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.globalAlpha = 1;
    }
    
    if (activeDecorations.has('corner')) {
      this.renderCorners(options.corner);
    }
    
    if (activeDecorations.has('pattern')) {
      this.renderPattern(options.pattern);
    }
  }

  getTextureImage() {
    // åˆ›å»ºçº¹ç†å›¾ç‰‡ï¼ˆè¿™é‡Œç”¨ç®€å•çš„canvasç”Ÿæˆï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨å›¾ç‰‡æ–‡ä»¶ï¼‰
    const textureCanvas = document.createElement('canvas');
    textureCanvas.width = 20;
    textureCanvas.height = 20;
    const txtCtx = textureCanvas.getContext('2d');
    txtCtx.strokeStyle = '#000';
    txtCtx.lineWidth = 0.5;
    txtCtx.beginPath();
    txtCtx.moveTo(0, 0);
    txtCtx.lineTo(20, 20);
    txtCtx.stroke();
    return textureCanvas;
  }

  saveImage() {
    const imageUrl = this.canvas.toDataURL('image/png');
    this.saveToHistory();
    chrome.runtime.sendMessage({
      action: 'saveImage',
      imageUrl: imageUrl
    });
  }

  renderBackgroundImage() {
    const { backgroundImage, backgroundSize, backgroundOpacity } = this.settings;
    
    this.ctx.save();
    this.ctx.globalAlpha = backgroundOpacity;
    
    if (backgroundSize === 'cover') {
      const scale = Math.max(
        this.canvas.width / backgroundImage.width,
        this.canvas.height / backgroundImage.height
      );
      const w = backgroundImage.width * scale;
      const h = backgroundImage.height * scale;
      const x = (this.canvas.width - w) / 2;
      const y = (this.canvas.height - h) / 2;
      
      this.ctx.drawImage(backgroundImage, x, y, w, h);
    } else if (backgroundSize === 'contain') {
      const scale = Math.min(
        this.canvas.width / backgroundImage.width,
        this.canvas.height / backgroundImage.height
      );
      const w = backgroundImage.width * scale;
      const h = backgroundImage.height * scale;
      const x = (this.canvas.width - w) / 2;
      const y = (this.canvas.height - h) / 2;
      
      this.ctx.drawImage(backgroundImage, x, y, w, h);
    } else if (backgroundSize === 'repeat') {
      const pattern = this.ctx.createPattern(backgroundImage, 'repeat');
      this.ctx.fillStyle = pattern;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    this.ctx.restore();
  }

  async loadHistory() {
    try {
      const result = await chrome.storage.local.get('imageHistory');
      this.history = result.imageHistory || [];
      this.renderHistory();
    } catch (err) {
      console.error('åŠ è½½å†å²è®°å½•å¤±è´¥:', err);
    }
  }

  async saveToHistory() {
    const imageData = {
      id: Date.now(),
      preview: this.canvas.toDataURL('image/png'),
      settings: { ...this.settings },
      text: this.selectedText,
      timestamp: new Date().toISOString()
    };

    this.history.unshift(imageData);
    if (this.history.length > 10) {
      this.history.pop();
    }

    try {
      await chrome.storage.local.set({ imageHistory: this.history });
      this.renderHistory();
    } catch (err) {
      console.error('ä¿å­˜å†å²è®°å½•å¤±è´¥:', err);
    }
  }

  renderHistory() {
    const historyList = document.querySelector('.history-list');
    historyList.innerHTML = this.history.map(item => `
      <div class="history-item" data-id="${item.id}">
        <img src="${item.preview}" alt="å†å²è®°å½•">
        <div class="history-info">
          <div class="history-text">${item.text.slice(0, 50)}...</div>
          <div class="history-time">${new Date(item.timestamp).toLocaleString()}</div>
        </div>
      </div>
    `).join('');
  }

  async showSharePanel() {
    const sharePanel = document.querySelector('.share-panel');
    sharePanel.style.display = 'block';
    
    // ç”Ÿæˆåˆ†äº«é“¾æ¥
    const imageUrl = this.canvas.toDataURL('image/png');
    const shareLink = await this.uploadImage(imageUrl);
    document.getElementById('shareLink').value = shareLink;
  }

  async uploadImage(imageUrl) {
    // è¿™é‡Œåº”è¯¥å®ç°å›¾ç‰‡ä¸Šä¼ åˆ°æœåŠ¡å™¨çš„é€»è¾‘
    // è¿”å›å¯è®¿é—®çš„URL
    return 'https://example.com/shared-image/123';
  }

  shareToPlaftorm(platform) {
    const shareUrl = document.getElementById('shareLink').value;
    const text = encodeURIComponent('åˆ†äº«ä¸€å¼ ç²¾ç¾çš„æ–‡å­—å›¾ç‰‡');
    
    let url;
    switch (platform) {
      case 'weibo':
        url = `http://service.weibo.com/share/share.php?url=${shareUrl}&title=${text}`;
        break;
      case 'twitter':
        url = `https://twitter.com/intent/tweet?url=${shareUrl}&text=${text}`;
        break;
      case 'wechat':
        // å¾®ä¿¡åˆ†äº«éœ€è¦è°ƒç”¨å¾®ä¿¡ JS-SDKï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
        alert('è¯·ä½¿ç”¨å¾®ä¿¡æ‰«æäºŒç»´ç åˆ†äº«');
        return;
    }
    
    window.open(url, '_blank');
  }

  async handleFontUpload(file) {
    try {
      // è¯»å–å­—ä½“æ–‡ä»¶
      const reader = new FileReader();
      reader.onload = async (e) => {
        const fontData = e.target.result.split(',')[1]; // è·å–base64æ•°æ®
        const fontName = file.name.replace(/\.[^/.]+$/, ""); // ç§»é™¤æ‰©å±•å
        
        // åˆ›å»ºå­—ä½“å¯¹è±¡
        const fontFace = new FontFace(fontName, `url(data:font/ttf;base64,${fontData})`);
        
        try {
          // åŠ è½½å­—ä½“
          const loadedFont = await fontFace.load();
          document.fonts.add(loadedFont);
          
          // ä¿å­˜å­—ä½“æ•°æ®
          this.customFonts.set(fontName, { name: fontName, data: fontData });
          
          // æ›´æ–°å­˜å‚¨
          await chrome.storage.local.set({
            customFonts: Array.from(this.customFonts.values())
          });
          
          // æ›´æ–°å­—ä½“é€‰æ‹©å™¨
          this.updateFontSelect();
          
          // åº”ç”¨æ–°å­—ä½“
          this.settings.fontFamily = fontName;
          this.render();
        } catch (err) {
          console.error('å­—ä½“åŠ è½½å¤±è´¥:', err);
          alert('å­—ä½“æ–‡ä»¶æ— æ•ˆæˆ–ä¸æ”¯æŒ');
        }
      };
      
      reader.readAsDataURL(file);
    } catch (err) {
      console.error('å­—ä½“ä¸Šä¼ å¤±è´¥:', err);
      alert('å­—ä½“ä¸Šä¼ å¤±è´¥');
    }
  }

  applyFilterPreset(preset) {
    const presets = {
      none: {
        brightness: 100,
        contrast: 100,
        saturation: 100,
        blur: 0
      },
      warm: {
        brightness: 110,
        contrast: 110,
        saturation: 120,
        blur: 0,
        colorOverlay: 'rgba(255, 150, 0, 0.1)'
      },
      cool: {
        brightness: 100,
        contrast: 105,
        saturation: 90,
        blur: 0,
        colorOverlay: 'rgba(0, 150, 255, 0.1)'
      },
      vintage: {
        brightness: 90,
        contrast: 120,
        saturation: 80,
        blur: 0.5,
        sepia: true
      }
    };

    this.settings.filters = { ...presets[preset] };
    this.updateFilterControls();
    this.render();
  }

  updateFilterControls() {
    Object.entries(this.settings.filters).forEach(([filter, value]) => {
      const control = document.getElementById(filter);
      if (control) {
        control.value = value;
      }
    });
  }

  applyFilters() {
    const { filters } = this.settings;
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    const data = imageData.data;

    // åº”ç”¨äº®åº¦ã€å¯¹æ¯”åº¦å’Œé¥±å’Œåº¦
    for (let i = 0; i < data.length; i += 4) {
      let r = data[i];
      let g = data[i + 1];
      let b = data[i + 2];

      // äº®åº¦
      const brightness = filters.brightness / 100;
      r *= brightness;
      g *= brightness;
      b *= brightness;

      // å¯¹æ¯”åº¦
      const contrast = filters.contrast / 100;
      const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
      r = factor * (r - 128) + 128;
      g = factor * (g - 128) + 128;
      b = factor * (b - 128) + 128;

      // é¥±å’Œåº¦
      const saturation = filters.saturation / 100;
      const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
      r = gray + saturation * (r - gray);
      g = gray + saturation * (g - gray);
      b = gray + saturation * (b - gray);

      // ç¡®ä¿é¢œè‰²å€¼åœ¨æœ‰æ•ˆèŒƒå›´å†…
      data[i] = Math.max(0, Math.min(255, r));
      data[i + 1] = Math.max(0, Math.min(255, g));
      data[i + 2] = Math.max(0, Math.min(255, b));
    }

    // åº”ç”¨æ¨¡ç³Šæ•ˆæœ
    if (filters.blur > 0) {
      this.applyBlur(imageData, filters.blur);
    }

    // åº”ç”¨ç‰¹æ®Šæ•ˆæœ
    if (filters.sepia) {
      this.applySepia(data);
    }

    this.ctx.putImageData(imageData, 0, 0);

    // åº”ç”¨é¢œè‰²å åŠ 
    if (filters.colorOverlay) {
      this.ctx.fillStyle = filters.colorOverlay;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
  }

  applyBlur(imageData, radius) {
    // ç®€å•çš„æ–¹æ¡†æ¨¡ç³Šå®ç°
    const width = this.canvas.width;
    const height = this.canvas.height;
    const data = imageData.data;
    const copy = new Uint8ClampedArray(data);

    const boxSize = Math.floor(radius);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        let count = 0;

        for (let dy = -boxSize; dy <= boxSize; dy++) {
          for (let dx = -boxSize; dx <= boxSize; dx++) {
            const px = x + dx;
            const py = y + dy;
            if (px >= 0 && px < width && py >= 0 && py < height) {
              const i = (py * width + px) * 4;
              r += copy[i];
              g += copy[i + 1];
              b += copy[i + 2];
              a += copy[i + 3];
              count++;
            }
          }
        }

        const i = (y * width + x) * 4;
        data[i] = r / count;
        data[i + 1] = g / count;
        data[i + 2] = b / count;
        data[i + 3] = a / count;
      }
    }
  }

  applySepia(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];

      data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
      data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
      data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
    }
  }

  toggleDecoration(type) {
    const { activeDecorations } = this.settings.decorations;
    if (activeDecorations.has(type)) {
      activeDecorations.delete(type);
      document.querySelector(`[data-type="${type}"]`).classList.remove('active');
    } else {
      activeDecorations.add(type);
      document.querySelector(`[data-type="${type}"]`).classList.add('active');
      this.showDecorationOptions(type);
    }
    this.render();
  }

  showDecorationOptions(type) {
    const options = this.settings.decorations.options[type];
    const optionsPanel = document.querySelector('.decoration-options');
    
    let html = '';
    switch (type) {
      case 'quote-marks':
        html = this.getQuoteOptionsHTML(options);
        break;
      case 'border':
        html = this.getBorderOptionsHTML(options);
        break;
      case 'watermark':
        html = this.getWatermarkOptionsHTML(options);
        break;
      case 'texture':
        html = this.getTextureOptionsHTML(options);
        break;
      case 'corner':
        html = this.getCornerOptionsHTML(options);
        break;
      case 'pattern':
        html = this.getPatternOptionsHTML(options);
        break;
    }
    
    optionsPanel.innerHTML = html;
    optionsPanel.style.display = 'block';
    this.bindDecorationOptions(type);
  }

  getQuoteOptionsHTML(options) {
    return `
      <div class="decoration-option">
        <label>é¢œè‰²</label>
        <input type="color" value="${options.color}" data-option="color">
      </div>
      <div class="decoration-option">
        <label>å¤§å°</label>
        <input type="range" min="36" max="120" value="${options.size}" data-option="size">
      </div>
      <div class="decoration-option">
        <label>ä½ç½®</label>
        <select data-option="position">
          <option value="top-left" ${options.position === 'top-left' ? 'selected' : ''}>å·¦ä¸Š</option>
          <option value="top-right" ${options.position === 'top-right' ? 'selected' : ''}>å³ä¸Š</option>
          <option value="bottom-left" ${options.position === 'bottom-left' ? 'selected' : ''}>å·¦ä¸‹</option>
          <option value="bottom-right" ${options.position === 'bottom-right' ? 'selected' : ''}>å³ä¸‹</option>
        </select>
      </div>
    `;
  }

  getBorderOptionsHTML(options) {
    return `
      <div class="decoration-option">
        <label>æ ·å¼</label>
        <select data-option="style">
          <option value="solid" ${options.style === 'solid' ? 'selected' : ''}>å®çº¿</option>
          <option value="dashed" ${options.style === 'dashed' ? 'selected' : ''}>è™šçº¿</option>
          <option value="double" ${options.style === 'double' ? 'selected' : ''}>åŒçº¿</option>
        </select>
      </div>
      <div class="decoration-option">
        <label>é¢œè‰²</label>
        <input type="color" value="${options.color}" data-option="color">
      </div>
      <div class="decoration-option">
        <label>å®½åº¦</label>
        <input type="range" min="1" max="10" value="${options.width}" data-option="width">
      </div>
      <div class="decoration-option">
        <label>åœ†è§’</label>
        <input type="range" min="0" max="50" value="${options.radius}" data-option="radius">
      </div>
    `;
  }

  getWatermarkOptionsHTML(options) {
    return `
      <div class="decoration-option">
        <label>æ–‡å­—</label>
        <input type="text" value="${options.text}" data-option="text">
      </div>
      <div class="decoration-option">
        <label>é€æ˜åº¦</label>
        <input type="range" min="0" max="100" value="${options.opacity * 100}" data-option="opacity">
      </div>
      <div class="decoration-option">
        <label>è§’åº¦</label>
        <input type="range" min="-180" max="180" value="${options.angle}" data-option="angle">
      </div>
    `;
  }

  getTextureOptionsHTML(options) {
    return `
      <div class="decoration-option">
        <label>å›¾æ¡ˆ</label>
        <select data-option="pattern">
          <option value="lines" ${options.pattern === 'lines' ? 'selected' : ''}>çº¿æ¡</option>
          <option value="dots" ${options.pattern === 'dots' ? 'selected' : ''}>åœ†ç‚¹</option>
          <option value="grid" ${options.pattern === 'grid' ? 'selected' : ''}>ç½‘æ ¼</option>
        </select>
      </div>
      <div class="decoration-option">
        <label>é€æ˜åº¦</label>
        <input type="range" min="0" max="100" value="${options.opacity * 100}" data-option="opacity">
      </div>
      <div class="decoration-option">
        <label>ç¼©æ”¾</label>
        <input type="range" min="0.5" max="2" step="0.1" value="${options.scale}" data-option="scale">
      </div>
    `;
  }

  getCornerOptionsHTML(options) {
    return `
      <div class="decoration-option">
        <label>æ ·å¼</label>
        <select data-option="style">
          <option value="simple" ${options.style === 'simple' ? 'selected' : ''}>ç®€çº¦</option>
          <option value="ornate" ${options.style === 'ornate' ? 'selected' : ''}>åä¸½</option>
          <option value="floral" ${options.style === 'floral' ? 'selected' : ''}>èŠ±çº¹</option>
        </select>
      </div>
      <div class="decoration-option">
        <label>é¢œè‰²</label>
        <input type="color" value="${options.color}" data-option="color">
      </div>
      <div class="decoration-option">
        <label>å¤§å°</label>
        <input type="range" min="20" max="100" value="${options.size}" data-option="size">
      </div>
    `;
  }

  getPatternOptionsHTML(options) {
    return `
      <div class="decoration-option">
        <label>ç±»å‹</label>
        <select data-option="type">
          <option value="dots" ${options.type === 'dots' ? 'selected' : ''}>åœ†ç‚¹</option>
          <option value="crosses" ${options.type === 'crosses' ? 'selected' : ''}>åå­—</option>
          <option value="stars" ${options.type === 'stars' ? 'selected' : ''}>æ˜Ÿå½¢</option>
        </select>
      </div>
      <div class="decoration-option">
        <label>é¢œè‰²</label>
        <input type="color" value="${options.color}" data-option="color">
      </div>
      <div class="decoration-option">
        <label>é€æ˜åº¦</label>
        <input type="range" min="0" max="100" value="${options.opacity * 100}" data-option="opacity">
      </div>
      <div class="decoration-option">
        <label>ç¼©æ”¾</label>
        <input type="range" min="0.5" max="2" step="0.1" value="${options.scale}" data-option="scale">
      </div>
    `;
  }

  bindDecorationOptions(type) {
    const optionsPanel = document.querySelector('.decoration-options');
    optionsPanel.querySelectorAll('[data-option]').forEach(input => {
      input.addEventListener('input', (e) => {
        const option = e.target.dataset.option;
        const value = e.target.type === 'range' ? parseInt(e.target.value) : e.target.value;
        this.settings.decorations.options[type][option] = value;
        this.render();
      });
    });
  }

  showExportPanel() {
    const panel = document.querySelector('.export-panel');
    panel.style.display = 'block';

    // åˆå§‹åŒ–è¾“å…¥å€¼
    document.getElementById('widthInput').value = this.canvas.width;
    document.getElementById('heightInput').value = this.canvas.height;
    this.updateEstimatedSize();
  }

  updateEstimatedSize() {
    const width = parseInt(document.getElementById('widthInput').value) || this.canvas.width;
    const height = parseInt(document.getElementById('heightInput').value) || this.canvas.height;
    const format = this.exportSettings.format;
    const quality = this.exportSettings.quality;

    // ä¼°ç®—æ–‡ä»¶å¤§å°ï¼ˆè¿™æ˜¯ä¸€ä¸ªç²—ç•¥çš„ä¼°ç®—ï¼‰
    let bitsPerPixel;
    switch (format) {
      case 'png':
        bitsPerPixel = 32;
        break;
      case 'jpeg':
        bitsPerPixel = 24 * quality;
        break;
      case 'webp':
        bitsPerPixel = 16 * quality;
        break;
    }

    const estimatedBytes = (width * height * bitsPerPixel) / 8;
    const estimatedMB = (estimatedBytes / (1024 * 1024)).toFixed(1);
    document.getElementById('estimatedSize').textContent = estimatedMB;
  }

  async exportImage() {
    const { format, quality, width, height } = this.exportSettings;

    // åˆ›å»ºä¸´æ—¶ç”»å¸ƒè¿›è¡Œç¼©æ”¾
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext('2d');

    // åº”ç”¨å¹³æ»‘ç¼©æ”¾
    tempCtx.imageSmoothingEnabled = true;
    tempCtx.imageSmoothingQuality = 'high';

    // ç»˜åˆ¶ç¼©æ”¾åçš„å›¾åƒ
    tempCtx.drawImage(this.canvas, 0, 0, width, height);

    // å¯¼å‡ºå›¾ç‰‡
    const mimeType = `image/${format}`;
    const imageUrl = tempCanvas.toDataURL(mimeType, quality);

    // åˆ›å»ºä¸‹è½½é“¾æ¥
    const link = document.createElement('a');
    link.download = `image-${Date.now()}.${format}`;
    link.href = imageUrl;
    link.click();
  }

  async copyToClipboard() {
    try {
      const blob = await new Promise(resolve => {
        this.canvas.toBlob(resolve, `image/${this.exportSettings.format}`, this.exportSettings.quality);
      });

      await navigator.clipboard.write([
        new ClipboardItem({
          [blob.type]: blob
        })
      ]);

      alert('å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (err) {
      console.error('å¤åˆ¶åˆ°å‰ªè´´æ¿å¤±è´¥:', err);
      alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®');
    }
  }

  renderCorners(options) {
    const { size, color, style } = options;
    this.ctx.strokeStyle = color;
    this.ctx.lineWidth = 2;
    
    // ç»˜åˆ¶å››ä¸ªè§’
    const corners = [
      [0, 0, 1, 1],  // å·¦ä¸Š
      [this.canvas.width, 0, -1, 1],  // å³ä¸Š
      [0, this.canvas.height, 1, -1],  // å·¦ä¸‹
      [this.canvas.width, this.canvas.height, -1, -1]  // å³ä¸‹
    ];
    
    corners.forEach(([x, y, dx, dy]) => {
      if (style === 'simple') {
        this.drawSimpleCorner(x, y, size, dx, dy);
      } else if (style === 'ornate') {
        this.drawOrnateCorner(x, y, size, dx, dy);
      } else if (style === 'floral') {
        this.drawFloralCorner(x, y, size, dx, dy);
      }
    });
  }

  drawSimpleCorner(x, y, size, dx, dy) {
    this.ctx.beginPath();
    this.ctx.moveTo(x, y);
    this.ctx.lineTo(x + (size * dx), y);
    this.ctx.moveTo(x, y);
    this.ctx.lineTo(x, y + (size * dy));
    this.ctx.stroke();
  }

  drawOrnateCorner(x, y, size, dx, dy) {
    const curve = size * 0.5;
    this.ctx.beginPath();
    this.ctx.moveTo(x, y);
    
    // ç»˜åˆ¶æ›²çº¿è£…é¥°
    if (dx > 0 && dy > 0) { // å·¦ä¸Šè§’
      this.ctx.bezierCurveTo(
        x + curve, y,
        x + size, y + curve,
        x + size, y + size
      );
      this.ctx.moveTo(x, y);
      this.ctx.bezierCurveTo(
        x, y + curve,
        x + curve, y + size,
        x + size, y + size
      );
    } else {
      // ç±»ä¼¼åœ°å¤„ç†å…¶ä»–è§’è½
      // æ ¹æ® dx å’Œ dy çš„ç¬¦å·è°ƒæ•´æ›²çº¿æ§åˆ¶ç‚¹
      const cx = x + (curve * dx);
      const cy = y + (curve * dy);
      this.ctx.bezierCurveTo(
        cx, y,
        x + (size * dx), cy,
        x + (size * dx), y + (size * dy)
      );
      this.ctx.moveTo(x, y);
      this.ctx.bezierCurveTo(
        x, cy,
        cx, y + (size * dy),
        x + (size * dx), y + (size * dy)
      );
    }
    
    this.ctx.stroke();
  }

  drawFloralCorner(x, y, size, dx, dy) {
    const petal = size * 0.3;
    this.ctx.save();
    this.ctx.translate(x, y);
    
    // æ ¹æ®è§’è½ä½ç½®æ—‹è½¬ç”»å¸ƒ
    if (dx < 0 && dy < 0) this.ctx.rotate(Math.PI);
    else if (dx < 0) this.ctx.rotate(Math.PI / 2);
    else if (dy < 0) this.ctx.rotate(-Math.PI / 2);
    
    // ç»˜åˆ¶èŠ±çº¹
    this.ctx.beginPath();
    for (let i = 0; i < 3; i++) {
      const angle = (i * Math.PI / 4);
      const x1 = Math.cos(angle) * petal;
      const y1 = Math.sin(angle) * petal;
      const x2 = Math.cos(angle + Math.PI/8) * size;
      const y2 = Math.sin(angle + Math.PI/8) * size;
      
      this.ctx.moveTo(0, 0);
      this.ctx.quadraticCurveTo(x1, y1, x2, y2);
    }
    this.ctx.stroke();
    
    // æ·»åŠ å°åœ†ç‚¹è£…é¥°
    this.ctx.beginPath();
    this.ctx.arc(petal, petal, 2, 0, Math.PI * 2);
    this.ctx.fill();
    
    this.ctx.restore();
  }

  renderPattern(options) {
    const { type, color, opacity, scale } = options;
    const pattern = this.createPattern(type, color, scale);
    
    this.ctx.save();
    this.ctx.globalAlpha = opacity;
    this.ctx.fillStyle = pattern;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.restore();
  }

  createPattern(type, color, scale) {
    const patternCanvas = document.createElement('canvas');
    const size = 20 * scale;
    patternCanvas.width = size;
    patternCanvas.height = size;
    const ctx = patternCanvas.getContext('2d');
    
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    
    switch (type) {
      case 'dots':
        this.drawDotsPattern(ctx, size);
        break;
      case 'crosses':
        this.drawCrossesPattern(ctx, size);
        break;
      case 'stars':
        this.drawStarsPattern(ctx, size);
        break;
    }
    
    return this.ctx.createPattern(patternCanvas, 'repeat');
  }

  drawDotsPattern(ctx, size) {
    const radius = size * 0.15;
    ctx.beginPath();
    ctx.arc(size/2, size/2, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // æ·»åŠ å››ä¸ªå°ç‚¹
    const smallRadius = radius * 0.5;
    [[0, 0], [0, size], [size, 0], [size, size]].forEach(([x, y]) => {
      ctx.beginPath();
      ctx.arc(x, y, smallRadius, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  drawCrossesPattern(ctx, size) {
    const lineWidth = size * 0.1;
    const length = size * 0.4;
    
    // ä¸­å¿ƒåå­—
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.moveTo(size/2, size/2 - length/2);
    ctx.lineTo(size/2, size/2 + length/2);
    ctx.moveTo(size/2 - length/2, size/2);
    ctx.lineTo(size/2 + length/2, size/2);
    ctx.stroke();
    
    // è§’è½å°åå­—
    const smallLength = length * 0.6;
    [[0, 0], [0, size], [size, 0], [size, size]].forEach(([x, y]) => {
      ctx.beginPath();
      ctx.moveTo(x, y - smallLength/2);
      ctx.lineTo(x, y + smallLength/2);
      ctx.moveTo(x - smallLength/2, y);
      ctx.lineTo(x + smallLength/2, y);
      ctx.stroke();
    });
  }

  drawStarsPattern(ctx, size) {
    // ä¸­å¿ƒå¤§æ˜Ÿæ˜Ÿ
    this.drawStar(ctx, size/2, size/2, 5, size * 0.25, size * 0.1);
    
    // è§’è½å°æ˜Ÿæ˜Ÿ
    const smallSize = size * 0.15;
    [[0, 0], [0, size], [size, 0], [size, size]].forEach(([x, y]) => {
      this.drawStar(ctx, x, y, 5, smallSize, smallSize * 0.4);
    });
  }

  drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    const step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    
    for(let i = 0; i < spikes; i++) {
      x = cx + Math.cos(rot) * outerRadius;
      y = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;

      x = cx + Math.cos(rot) * innerRadius;
      y = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += step;
    }
    
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
  }
}

// åˆå§‹åŒ–ç¼–è¾‘å™¨
window.addEventListener('DOMContentLoaded', () => {
  new ImageEditor();
}); 